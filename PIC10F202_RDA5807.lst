MPASM  5.51              PIC20X_PIC12F50X.ASM   8-28-2025  20:24:23         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001 ;*******************************************************************************
                      00002  TITLE      PIC20X+PIC12F50X+RDA5807M+IR.asm
                      00003  SUBTITLE PIC10F200, PIC10F202, PIC12F508 & PIC12F509                                            *
                      00004 ; CONTENTS:  I²C RDA5807M + IR REMOTE Control                       *
                      00005 ; COPYRIGHT: DollY LAB. 2020-2030                                              *
                      00006 ; AUTHOR:    Nikola Tesla                                                      *
                      00007 ; UPDATED:   15/08/2025                                             *
                      00008 ;*******************************************************************************
                      00009  
                      00010  radix DEC
0200   0005 0008 0000 00011  __idlocs H'5807'
       0007 
0FFF   0FEB           00012  __CONFIG _IntRC_OSC & _WDT_OFF & _CP_OFF & _MCLRE_OFF;
                      00013 
                      00014  ifdef __10F200 
                      00015  include "p10F200.inc"
                      00016  list    p=10F200
                      00017  endif
                      00018 
                      00019  ifdef __10F202
                      00020  include "p10F202.inc"
                      00001         LIST
                      00002 
                      00003 ;==========================================================================
                      00004 ;  MPASM PIC10F202 processor include
                      00005 ; 
                      00006 ;  (c) Copyright 1999-2013 Microchip Technology, All rights reserved
                      00007 ;==========================================================================
                      00008 
                      00150         LIST
                      00021  list p=10F202
                      00022  endif
                      00023      
                      00024  ifdef __12F508
                      00025  include "p12F508.inc"
                      00026  list p=12F508
                      00027  endif
                      00028 
                      00029  ifdef __12F509
                      00030  include "p12F509.inc"
                      00031  list p=12F509
                      00032  endif
                      00033 
                      00034  errorlevel +205,+207,+302,+305,+306
                      00035 
                      00036 ;*******************************************************************************
                      00037 ; File register usage                                                          *
                      00038 ;*******************************************************************************
                      00039      ifdef __10F200
                      00040 RAM  equ  H'010'
                      00041 MAXRAM  set  H'0020'
                      00042      endif
                      00043      ifdef __10F202
MPASM  5.51              PIC20X_PIC12F50X.ASM   8-28-2025  20:24:23         PAGE  2
PIC20X+PIC12F50X+RDA5807M+IR.asm
PIC10F200, PIC10F202, PIC12F508 & PIC12F509                                            *
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000008            00044 RAM  equ  h'08'
  0000001F            00045 MAXRAM  set  H'001F'
                      00046      endif
                      00047      ifdef __12F508
                      00048 RAM  equ  h'07'
                      00049 MAXRAM  set  H'01F'
                      00050      endif
                      00051      ifdef __12F509
                      00052 RAM  equ  H'007'
                      00053 MAXRAM  set  H'03F'
                      00054      endif
                      00055 ;********************************************************************
                      00056                 CBLOCK RAM      
                      00057 ;********************************************************************
  00000008            00058 i           ;EQU    010h    ;Delay variable
  00000009            00059 j           ;EQU    011h    ;Delay variable
  0000000A            00060 bit_count   ;EQU    012h    ;Counter of processed bits in I2C
  0000000B            00061 i2c_data    ;EQU    013h    ;Data to receive/transmit via I2C
  0000000C            00062 port        ;EQU    014h    ;Helper register to implement I2C
  0000000D            00063 ack         ;EQU    015h    ;Acknowledgment received from the device
  0000000E            00064 volume      ;EQU    016h    ;Radio volume level
  0000000F            00065 frequency_l ;EQU    017h    ;Frequency low byte
  00000010            00066 frequency_h ;EQU    0018h    ;Frequency high byte
                      00067 ;********************************************************************
  00000011            00068 _count      ;EQU    019h    ;Saved value of the timer
  00000012            00069 _byte_count ;EQU    01Ah    ;Counter of processed bytes
  00000013            00070 _bit_count  ;EQU    01Bh    ;Counter of processed bits
  00000014            00071 _ir_data:4  ;EQU    01Ch    ;First IR byte
                      00072 ;********************************************************************
                      00073 
  00000018            00074 RAM_            
                      00075                 ENDC
                      00076 
                      00077         if RAM_ > MAXRAM
                      00078         error "File register usage overflow"
                      00079         endif
                      00080 ;###############################################################################
                      00081 
                      00082 ;SCL        EQU    GP1    ;SCL pin of the I²C Bus
                      00083 ;SDA        EQU    GP2    ;SDA pin of the I²C Bus
                      00084 ;IRx        EQU    GP3    ;INPUT ONLY PIN(IR Rx 38kHz)
                      00085 
                      00086      ifdef __10F200
                      00087 SDA         EQU    GP2    ;SDA pin of the I2C
                      00088 SCL         EQU    GP1    ;SCL pin of the I2C
                      00089 IRx         EQU    GP3    ;INPUT ONLY PIN(IR Rx 38kHz)
                      00090      endif
                      00091 
                      00092      ifdef __10F202
  00000002            00093 SDA         EQU    GP2    ;SDA pin of the I2C
  00000001            00094 SCL         EQU    GP1    ;SCL pin of the I2C
  00000003            00095 IRx         EQU    GP3    ;INPUT ONLY PIN(IR Rx 38kHz) 
                      00096      endif
MPASM  5.51              PIC20X_PIC12F50X.ASM   8-28-2025  20:24:23         PAGE  3
PIC20X+PIC12F50X+RDA5807M+IR.asm
PIC10F200, PIC10F202, PIC12F508 & PIC12F509                                            *
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00097 
                      00098      ifdef __12F508 
                      00099 IRx        EQU    GP3    ;INPUT ONLY PIN(IR Rx 38kHz)
                      00100 SCL        EQU    GP4    ;SCL pin of the I²C Bus
                      00101 SDA        EQU    GP5    ;SDA pin of the I²C Bus
                      00102      endif
                      00103 
                      00104      ifdef __12F509 
                      00105 IRx        EQU    GP3    ;INPUT ONLY PIN(IR Rx 38kHz)
                      00106 SCL        EQU    GP4    ;SCL pin of the I²C Bus
                      00107 SDA        EQU    GP5    ;SDA pin of the I²C Bus
                      00108      endif
                      00109 
                      00110 ;###############################################################################
                      00111 
                      00112 ;###############################################################################
                      00113 ; DEFAULT STARTING FREQUENCY and VOLUME - Enter your own Frequency
                      00114 ;###############################################################################
                      00115 
                      00116 ;volume_init EQU 0x03 | 0x80; Initial Volume = 3 // [0..15]
  00000083            00117 volume_init EQU 0x03 | 1<<7 ;0x80; Initial Volume = 3 // [0..15]
                      00118 ;//volume EQU (volume_init | 0x80);
                      00119 
  00000397            00120 freq  EQU d'919';     91.9 MHz
                      00121 ;freq  EQU d'943'  ;   94.3 MHz
                      00122 ;freq  EQU d'1040';  104.0 MHz
                      00123 
                      00124 ;freqB EQU (freq - d'870') ; BAND = 0 : 87~108 MHz (US/Europe)
  00000229            00125 freqB EQU (freq - 366) ; BAND = 0 : 87~108 MHz (US/Europe)
  0000008A            00126 freqH EQU (freqB >> 2)    ; Frequency = Channel Spacing(kHz) x CHAN + 87.0 MHz
  00000040            00127 freqL EQU ((freqB&3) << 6); ; Shift channel selection for matching register 0x03
                      00128 
0000                  00129         ORG    0x00
                      00130  
0000   0EFE           00131    andlw   ~1
0001   0025           00132    movwf   OSCCAL
                      00133 
                      00134 ;///////////////////////////////////////////////////////////////////////////////
                      00135 ;       MOVLW 0x10 ;initialize pointer
                      00136 ;       MOVWF FSR ;to RAM
                      00137 ;NEXT 
                      00138 ;       CLRF INDF ;clear INDF ;register
                      00139 ;       INCF FSR,F ;inc pointer
                      00140 ;       BTFSC FSR,4 ;all done?
                      00141 ;       GOTO NEXT ;NO, clear next
                      00142 ;///////////////////////////////////////////////////////////////////////////////
                      00143 
0002                  00144 INIT:
0002   0C97           00145     MOVLW  ~((1<<T0CS)|(1<<NOT_GPPU)|(1<<PSA))
0003   0002           00146     OPTION                ;Enable GPIO2 and pull-ups
                      00147 
                      00148 ;    MOVLW  0x0F           ;Save 0x3F into 'port' register
0004   0C3F           00149         MOVLW  0x3F           ;Save 0x3F into 'port' register
MPASM  5.51              PIC20X_PIC12F50X.ASM   8-28-2025  20:24:23         PAGE  4
PIC20X+PIC12F50X+RDA5807M+IR.asm
PIC10F200, PIC10F202, PIC12F508 & PIC12F509                                            *
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0005   002C           00150     MOVWF  port           ;It's used to switch SDA/SCL pins direction
0006   0006           00151     TRIS   GPIO           ;Set all pins as inputs
                      00152 
0007   0CFF           00153     MOVLW  0xFF           ;Perform 200 ms delay
0008   098D           00154     CALL   DELAY          ;to let the power stabilize
                      00155 ;###############################################################################
0009   0CFF           00156     MOVLW  0xFF           ;Perform 400 ms delay
000A   098D           00157     CALL   DELAY          ;to let the power stabilize
                      00158 
000B   0CFF           00159     MOVLW  0xFF           ;Perform 600 ms delay
000C   098D           00160     CALL   DELAY          ;to let the power stabilize
                      00161 ;
000D   0CFF           00162     MOVLW  0xFF           ;Perform 800 ms delay
000E   098D           00163     CALL   DELAY          ;to let the power stabilize
                      00164 ;
                      00165 ;    MOVLW  0xFF           ;Perform 200 ms delay
                      00166 ;   CALL   DELAY          ;to let the power stabilize
                      00167 
                      00168 ;    MOVLW  0xFF           ;Perform 200 ms delay
                      00169 ;    CALL   DELAY          ;to let the power stabilize
                      00170 ;###############################################################################
                      00171 
000F   0066           00172     CLRF   GPIO           ;Clear GPIO to set all pins to 0
                      00173 
                      00174 ;READ_EEPROM:              ;Reading the stored data from EEPROM
                      00175 
0010   0C83           00176  movlw volume_init;  0x83 ////////////
0011   0C0E           00177  movlw volume
                      00178 
                      00179 ; movlw 0x40 ;91.90 MHz
0012   0C40           00180  movlw freqL ;91.90 MHz
0013   002F           00181  movwf frequency_l
                      00182 ; movlw 0x0C ;91.90 MHz
0014   0C8A           00183  movlw freqH ;91.90 MHz
0015   0030           00184  movwf frequency_h
                      00185 ;
0016   0CC0           00186     MOVLW  0xC0           ;Implement AND operation between 0xC0
0017   016F           00187     ANDWF  frequency_l, F ;and 'frequency_l' to clear its last 6 bits
0018   058F           00188     BSF    frequency_l, 4 ;Set bit 4 (Tune) to adjust the frequency
                      00189 
                      00190 ;START_RADIO:              ;Start FM radio
0019   095D           00191     CALL   I2C_START      ;Issue I2C Start condition
001A   0C20           00192     MOVLW  0x20           ;Radio chip address for sequential writing is 0x20
001B   0964           00193     CALL   I2C_WRITE_BYTE ;Write the radio address via i2C
001C   0CC0           00194     MOVLW  0xC0           ;Write high byte into radio register 0x02
                      00195 ;   MOVLW  0xD0           ;TEST added to enable BASS 
001D   0964           00196     CALL   I2C_WRITE_BYTE
001E   0C01           00197     MOVLW  0x01           ;Write  low byte into radio register 0x02
001F   0964           00198     CALL   I2C_WRITE_BYTE
0020   0210           00199     MOVF   frequency_h, W ;Write high byte into radio register 0x03
0021   0964           00200     CALL   I2C_WRITE_BYTE
0022   020F           00201     MOVF   frequency_l, W ;Write  low byte into radio register 0x03
0023   0964           00202     CALL   I2C_WRITE_BYTE
MPASM  5.51              PIC20X_PIC12F50X.ASM   8-28-2025  20:24:23         PAGE  5
PIC20X+PIC12F50X+RDA5807M+IR.asm
PIC10F200, PIC10F202, PIC12F508 & PIC12F509                                            *
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0024   0960           00203     CALL   I2C_STOP       ;Issue I2C Stop condition
                      00204 
0025   0C0F           00205     MOVLW  0x0F           ;Implement AND operation between 0xC0
0026   016E           00206     ANDWF  volume, F      ;and 'volume' to clear its higher 4 bits
0027   05EE           00207     BSF    volume, 7      ;Set bit 7  to select correct LNA input
0028   0A30           00208     GOTO   SET_VOLUME     ;And go to the 'SET_VOLUME' label
                      00209 
0029                  00210 LOOP:                     
                      00211 
                      00212 ;BUTTONS_LOOP:             ;Loop while button is pressed
                      00213 
0029                  00214 INCREASE_VOLUME:          ;Otherwise start 'INCREASE_VOLUME'
0029   02AE           00215     INCF   volume, F      ;Increment the 'volume' register
002A   068E           00216     BTFSC  volume, 4      ;If bit 4 becomes set (volume = 0b10010000)
002B   00EE           00217     DECF   volume, F      ;then decrement the 'volume' to get 0b10001111
002C   0A30           00218     GOTO   SET_VOLUME     ;and go to the 'SET_VOLUME' label
002D                  00219 DECREASE_VOLUME:          ;Decrease the volume here
002D   00EE           00220     DECF   volume, F      ;Decrement the 'volume' register
002E   07EE           00221     BTFSS  volume, 7      ;If bit 7 becomes 0 (volume = 0b01111111)
002F   02AE           00222     INCF   volume, F      ;then increment the 'volume' to get 0b10000000
0030                  00223 SET_VOLUME:               ;Set the radio volume
0030   095D           00224     CALL   I2C_START      ;Issue I2C start condition
0031   0C22           00225     MOVLW  0x22           ;Radio chip address for random writing is 0x22
0032   0964           00226     CALL   I2C_WRITE_BYTE ;Write the radio address via I2C
0033   0C05           00227     MOVLW  0x05           ;Set the register number to write to (0x05)
0034   0964           00228     CALL   I2C_WRITE_BYTE ;And write it via I2C
0035   0C88           00229     MOVLW  0x88           ;Set the high byte of 0x05 register (default value)
0036   0964           00230     CALL   I2C_WRITE_BYTE ;And write it via i2C
0037   020E           00231     MOVF   volume, W      ;Set the 'volume' as low byte of 0x05 register
0038   0964           00232     CALL   I2C_WRITE_BYTE ;And write it via I2C
0039   0960           00233     CALL   I2C_STOP       ;Issue Stop condition
                      00234 
003A   0A94           00235     GOTO   _LOOP           ;And return to the 'LOOP' label
                      00236 
                      00237 ;CHANNEL_SEEK:             ;Here button is released and we check what to do
                      00238 
003B                  00239 CH_UP:
003B   095D           00240     CALL   I2C_START      ;Issue I2C Start condition
003C   0C20           00241     MOVLW  0x20           ;Radio chip address for sequential writing is 0x20
003D   0964           00242     CALL   I2C_WRITE_BYTE ;Write the radio address via I2C
                      00243 
003E   0CC3           00244     MOVLW  0xC3           ;Otherwise set 0xC3 as high byte of 0x02 register
003F   0964           00245     CALL   I2C_WRITE_BYTE ;And write it via I2C
0040   0C01           00246     MOVLW  0x01           ;Set 0x01 as low byte of 0x02 register
0041   0964           00247     CALL   I2C_WRITE_BYTE ;And write it via I2C
0042   0960           00248     CALL   I2C_STOP       ;Issue I2C Stop condition
0043   0A94           00249     GOTO   _LOOP           ;And return to the 'LOOP' labe;
                      00250 
0044                  00251 SEEK_DOWN:                ;Seek the station down
                      00252 
0044   095D           00253     CALL   I2C_START      ;ADDEDIssue I2C Start condition
0045   0C20           00254     MOVLW  0x20           ;ADDEDRadio chip address for sequential writing is 0x20
0046   0964           00255     CALL   I2C_WRITE_BYTE ;ADDEDWrite the radio address via I2C
MPASM  5.51              PIC20X_PIC12F50X.ASM   8-28-2025  20:24:23         PAGE  6
PIC20X+PIC12F50X+RDA5807M+IR.asm
PIC10F200, PIC10F202, PIC12F508 & PIC12F509                                            *
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00256 
0047   0CC1           00257     MOVLW  0xC1           ;Set 0xC1 as high byte of 0x02 register
0048   0964           00258     CALL   I2C_WRITE_BYTE ;Ending of previous transaction
0049   0C01           00259     MOVLW  0x01           ;Set 0x01 as low byte of 0x02 register
004A   0964           00260     CALL   I2C_WRITE_BYTE ;And write it via I2C
004B   0960           00261     CALL   I2C_STOP       ;Issue I2C Stop condition
004C   0A94           00262     GOTO   _LOOP           ;And return to the 'LOOP' labe;
                      00263 
                      00264 ;-------------Helper subroutines---------------
004D                  00265 SDA_HIGH:                 ;Set SDA pin high
004D   054C           00266     BSF    port, SDA      ;Set 'sda' bit in the 'port' to make it input
004E   020C           00267     MOVF   port, W        ;Copy 'port' into W register
004F   0006           00268     TRIS   GPIO           ;And set it as TRISGPIO value
0050   0800           00269     RETLW  0
                      00270 
0051                  00271 SDA_LOW:                  ;Set SDA pin low
0051   044C           00272     BCF    port, SDA      ;Reset 'sda' bit in the 'port' to make it output
0052   020C           00273     MOVF   port, W        ;Copy 'port' into W register
0053   0006           00274     TRIS   GPIO           ;And set it as TRISGPIO value
0054   0800           00275     RETLW  0
                      00276 
0055                  00277 SCL_HIGH:                 ;Set SCL pin high
0055   052C           00278     BSF    port, SCL      ;Set 'scl' bit in the 'port' to make it input
0056   020C           00279     MOVF   port, W        ;Copy 'port' into W register
0057   0006           00280     TRIS   GPIO           ;And set it as TRISGPIO value
0058   0800           00281     RETLW  0
                      00282 
0059                  00283 SCL_LOW:                  ;Set SCL pin low
0059   042C           00284     BCF    port, SCL      ;Reset 'scl' bit in the 'port' to make it output
005A   020C           00285     MOVF   port, W        ;Copy 'port' into W register
005B   0006           00286     TRIS   GPIO           ;And set it as TRISGPIO value
005C   0800           00287     RETLW  0
                      00288 ;-------------I2C start condition--------------
005D                  00289 I2C_START:
005D   0955           00290     CALL   SCL_HIGH       ;Set SCL high
005E   0951           00291     CALL   SDA_LOW        ;Then set SDA low
005F   0800           00292     RETLW  0
                      00293 ;-------------I2C stop condition---------------
0060                  00294 I2C_STOP:
0060   0951           00295     CALL   SDA_LOW        ;Set SDA low
0061   0955           00296     CALL   SCL_HIGH       ;Set SCL high
0062   094D           00297     CALL   SDA_HIGH       ;Then set SDA highs and release the bus
0063   0800           00298     RETLW  0
                      00299 ;------------I2C write byte--------------------
0064                  00300 I2C_WRITE_BYTE:
0064   002B           00301     MOVWF  i2c_data       ;Load 'i2c_data' from W register
0065   0C08           00302     MOVLW  8              ;Load value 8 into 'bit_count'
0066   002A           00303     MOVWF  bit_count      ;to indicate we're going to send 8 bits
0067                  00304 I2C_WRITE_BIT:            ;Write single bit to I2C
0067   0959           00305     CALL   SCL_LOW        ;Set SCL low, now we can change SDA
0068   07EB           00306     BTFSS  i2c_data, 7    ;Check the MSB of 'i2c_data'
0069   0A6C           00307     GOTO   I2C_WRITE_0    ;If it's 0 then go to the 'I2C_WRITE_0' label
006A                  00308 I2C_WRITE_1:              ;Else continue with 'I2C_WRITE_1'
MPASM  5.51              PIC20X_PIC12F50X.ASM   8-28-2025  20:24:23         PAGE  7
PIC20X+PIC12F50X+RDA5807M+IR.asm
PIC10F200, PIC10F202, PIC12F508 & PIC12F509                                            *
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

006A   094D           00309     CALL   SDA_HIGH       ;Set SDA high
006B   0A6D           00310     GOTO   I2C_SHIFT      ;And go to the 'I2C_SHIFT' label
006C                  00311 I2C_WRITE_0:
006C   0951           00312     CALL   SDA_LOW        ;Set SDA low
006D                  00313 I2C_SHIFT:
006D   0955           00314     CALL   SCL_HIGH       ;Set SCL high to start the new pulse
006E   036B           00315     RLF    i2c_data, F     ;Shift 'i2c_data' one bit to the left
006F   02EA           00316     DECFSZ bit_count, F   ;Decrement the 'bit_count' value, check if it's 0
0070   0A67           00317     GOTO   I2C_WRITE_BIT  ;If not then return to the 'I2C_WRITE_BIT'
0071                  00318 I2C_CHECK_ACK:            ;Else check the acknowledgement bit
0071   0959           00319     CALL   SCL_LOW        ;Set I2C low to end the last pulse
0072   094D           00320     CALL   SDA_HIGH       ;Set SDA high to release the bus
0073   0955           00321     CALL   SCL_HIGH       ;Set I2C high to start the new pulse
0074   0206           00322     MOVF   GPIO, W        ;Copy the GPIO register value into the 'ack'
0075   002D           00323     MOVWF  ack            ;Now bit 'sda' of the 'ack' will contain ACK bit
0076   0959           00324     CALL   SCL_LOW        ;Set SCL low to end the acknowledgement bit
0077   0800           00325     RETLW  0
                      00326 ;------------I2C read byte--------------------
0078                  00327 I2C_READ_BYTE:
0078   0C08           00328     MOVLW  8              ;Load value 8 into 'bit_count'
0079   002A           00329     MOVWF  bit_count      ;to indicate we're going to receive 8 bits
007A   006B           00330     CLRF   i2c_data       ;Clear the 'i2c_data' register
007B                  00331 I2C_READ_BIT:             ;Read single bit from the I2C
007B   036B           00332     RLF    i2c_data, F    ;Shift the 'i2c_data' register one bit to the left
007C   0959           00333     CALL   SCL_LOW        ;Set SCL low to prepare for the new bit
007D   0955           00334     CALL   SCL_HIGH       ;Set SCL high to read the bit value
007E   0646           00335     BTFSC  GPIO, SDA      ;Check the 'sda' bit in the GPIO register
007F   050B           00336     BSF    i2c_data, 0    ;if it's 1 then set the LSB of the 'i2c_data'
0080   02EA           00337     DECFSZ bit_count, F   ;Decrement the 'bit_count' value, check if it's 0
0081   0A7B           00338     GOTO   I2C_READ_BIT   ;If not, then return to the 'I2C_READ_BIT'
0082   0959           00339     CALL   SCL_LOW        ;Set SCL low to end the last pulse
0083   0800           00340     RETLW  0              ;Otherwise return from the subroutine
                      00341 ;----------I2C send ACK----------------------
0084                  00342 I2C_ACK:
0084   0951           00343     CALL   SDA_LOW        ;Set SDA low to issue ACK condition
0085   0955           00344     CALL   SCL_HIGH       ;Set SCL high to start the new pulse
0086   0959           00345     CALL   SCL_LOW        ;Set SCL low to end the pulse
0087   094D           00346     CALL   SDA_HIGH       ;Set SDA high to release the bus
0088   0800           00347     RETLW  0
                      00348 ;----------I2C send NACK----------------------
0089                  00349 I2C_NACK:
0089   094D           00350     CALL   SDA_HIGH       ;Set SDA low to issue NACK condition
008A   0955           00351     CALL   SCL_HIGH       ;Set SCL high to start the new pulse
008B   0959           00352     CALL   SCL_LOW        ;Set SCL low to end the pulse
008C   0800           00353     RETLW  0
                      00354 ;-------------Delay subroutine--------------
008D                  00355 DELAY:                    ;Start DELAY subroutine here  
008D   0028           00356     MOVWF  i              ;Copy the value to the register i
008E   0029           00357     MOVWF  j              ;Copy the value to the register j
008F                  00358 DELAY_LOOP:               ;Start delay loop
008F   02E8           00359     DECFSZ i, F           ;Decrement i and check if it is not zero
0090   0A8F           00360     GOTO   DELAY_LOOP     ;If not, then go to the DELAY_LOOP label
0091   02E9           00361     DECFSZ j, F           ;Decrement j and check if it is not zero
MPASM  5.51              PIC20X_PIC12F50X.ASM   8-28-2025  20:24:23         PAGE  8
PIC20X+PIC12F50X+RDA5807M+IR.asm
PIC10F200, PIC10F202, PIC12F508 & PIC12F509                                            *
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0092   0A8F           00362     GOTO   DELAY_LOOP     ;If not, then go to the DELAY_LOOP label
0093   0800           00363     RETLW  0              ;Else return from the subroutine
                      00364 ;##############################################################################
                      00365 ;---IR REMOTE CONTROL 38kHz ROUTINE----------------/[NEC]\---------------------
                      00366 ;##############################################################################
                      00367 
0094                  00368 _LOOP:                    ;Main loop of the program
                      00369 ;---------------Wait for the preamble positive pulse---------------------
0094   0666           00370     BTFSC GPIO, IRx       ;Wait while 'ir' pin goes down
0095   0A94           00371     GOTO _LOOP           ;If it's high then return to 'LOOP'
0096   0061           00372     CLRF  TMR0           ;Otherwise clear the timer register
0097   0766           00373     BTFSS GPIO, IRx       ;And wait while 'ir' is low
0098   0A97           00374     GOTO  $-1
0099   0201           00375     MOVF  TMR0, W        ;Copy the TMR0 value into the W register
009A   0031           00376     MOVWF _count         ;and save the value into the 'count' register
009B   0C1E           00377     MOVLW d'30'          ;Load 30 into W (256 us x 32 = 7.7 ms)
009C   0091           00378     SUBWF _count, W      ;And subtract W from 'count'
009D   0703           00379     BTFSS STATUS, C      ;If 'count' < 30 (pulse is shorter than 7.7 ms)
009E   0A94           00380     GOTO  _LOOP          ;then return to 'LOOP'
009F   0C2D           00381     MOVLW d'45'          ;Load 45 into W (256 us x 45 = 11.5 ms)
00A0   0091           00382     SUBWF _count, W      ;And subtract W from 'count'
00A1   0603           00383     BTFSC STATUS, C      ;If 'count' > 45 (pulse is longer than 8 ms)
00A2   0A94           00384     GOTO _LOOP           ;then return to 'LOOP'
                      00385 ;---------------Check the preamble negative pulse---------------------
00A3   0061           00386     CLRF TMR0            ;Otherwise clear the timer register
00A4   0666           00387     BTFSC GPIO, IRx       ;And wait while 'ir' is high
00A5   0AA4           00388     GOTO $-1
00A6   0201           00389     MOVF TMR0, W         ;Copy the TMR0 value into the W register
00A7   0031           00390     MOVWF _count         ;and save the value into the 'count' register
00A8   0C0D           00391     MOVLW d'13'          ;Load 15 into W (256 us x 13 = 3.3 ms)
00A9   0091           00392     SUBWF _count, W      ;And subtract W from 'count'
00AA   0703           00393     BTFSS STATUS, C      ;If 'count' < 13 (pulse is shorter than 3.3 ms)
00AB   0A94           00394     GOTO _LOOP           ;then return to 'LOOP'
00AC   0C14           00395     MOVLW d'20'          ;Load 20 into W (256 us x 20 = 5.1 ms)
00AD   0091           00396     SUBWF _count, W      ;And subtract W from 'count'
00AE   0603           00397     BTFSC STATUS, C      ;If 'count' > 20 (pulse is longer than 5.1 ms)
00AF   0A94           00398     GOTO _LOOP           ;then return to 'LOOP'
                      00399 ;---------------Receive the command bytes-----------------------------
00B0   0072           00400     CLRF _byte_count     ;Clear the 'byte_count' register    
00B1   0C14           00401     MOVLW _ir_data       ;Load the address of the 'ir_data' into W
00B2   0024           00402     MOVWF FSR            ;and save it to the indirect pointer register
00B3                  00403 _RECEIVE_BYTE:
00B3   0073           00404     CLRF _bit_count      ;Clear the 'bit_count' register
00B4   0060           00405     CLRF INDF            ;Clear the indirectly addressed register
00B5                  00406 _RECEIVE_BIT:
00B5   0320           00407     RRF INDF, F          ;Shift the INDF register to the right
                      00408 ;---------------Receive the positive pulse of the bit-----------------
00B6   0061           00409     CLRF TMR0           ;Otherwise clear the timer register
00B7   0766           00410     BTFSS GPIO, IRx      ;And wait while 'ir' is low
00B8   0AB7           00411     GOTO $-1
00B9   0201           00412     MOVF TMR0, W        ;Copy the TMR0 value into the W register
00BA   0031           00413     MOVWF _count         ;and save the value into the 'count' register
00BB   0C01           00414     MOVLW 1             ;Load 1 into W (256 us x 1 = 0.26 ms)
MPASM  5.51              PIC20X_PIC12F50X.ASM   8-28-2025  20:24:23         PAGE  9
PIC20X+PIC12F50X+RDA5807M+IR.asm
PIC10F200, PIC10F202, PIC12F508 & PIC12F509                                            *
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00BC   0091           00415     SUBWF _count, W      ;And subtract W from 'count'
00BD   0703           00416     BTFSS STATUS, C     ;If 'count' < 1 (pulse is shorter than 0.26 ms)
00BE   0A94           00417     GOTO _LOOP           ;then return to 'LOOP'
00BF   0C03           00418     MOVLW 3             ;Load 3 into W (256 us x 3 = 0.77 ms)
00C0   0091           00419     SUBWF _count, W      ;And subtract W from 'count'
00C1   0603           00420     BTFSC STATUS, C     ;If 'count' > 3 (pulse is longer than 0.77 ms)
00C2   0A94           00421     GOTO _LOOP           ;then return to 'LOOP'
                      00422 ;---------------Receive the negative pulse of the bit-----------------
00C3   0061           00423     CLRF TMR0           ;Otherwise clear the timer register
00C4   0666           00424     BTFSC GPIO, IRx     ;And wait while 'ir' is high
00C5   0AC4           00425     GOTO $-1
00C6   0201           00426     MOVF TMR0, W        ;Copy the TMR0 value into the W register
00C7   0031           00427     MOVWF _count        ;and save the value into the 'count' register
00C8   0C04           00428     MOVLW 4;///////////             ;Load 5 into W (256 us x 4 = 1.1 ms)
00C9   0091           00429     SUBWF _count, W      ;And subtract W from 'count'
00CA   0703           00430     BTFSS STATUS, C     ;If 'count' < 4 (pulse is shorter than 1.1 ms)
00CB   0AD1           00431     GOTO _NEXT_BIT       ;then go to the 'NEXT_BIT' label
00CC   0C08           00432     MOVLW 8             ;Load 8 into W (256 us x 8 = 2 ms)
00CD   0091           00433     SUBWF _count, W      ;And subtract W from 'count'
00CE   0603           00434     BTFSC STATUS, C     ;If 'count' > 8 (pulse is longer than 2 ms)
00CF   0A94           00435     GOTO _LOOP           ;then go to the 'LOOP' label
00D0   05E0           00436     BSF INDF, 7         ;Set the MSB of the INDF register
00D1                  00437 _NEXT_BIT:
00D1   02B3           00438     INCF _bit_count, F   ;Increment the 'bit_count' register
00D2   0773           00439     BTFSS _bit_count, 3  ;Check if 'bit_count' becomes 8
00D3   0AB5           00440     GOTO _RECEIVE_BIT    ;If it's not, then return to 'RECEIVE_BIT' label
00D4   02B2           00441     INCF _byte_count, F  ;Increment the 'byte_count' register
00D5   0652           00442     BTFSC _byte_count, 2 ;Check if 'byte_count' becomes 4    
00D6   0AD9           00443     GOTO _CHECK_DATA     ;If it is then go to 'CHECK_DATA' label
00D7   02A4           00444     INCF FSR, F         ;Increment the indirect addressing pointer
00D8   0AB3           00445     GOTO _RECEIVE_BYTE   ;and go to 'RECEIVE_BYTE' label
                      00446 
00D9                  00447 _CHECK_DATA:
00D9   0255           00448     COMF _ir_data+1, W   ;Negate the second received byte
00DA   0194           00449     XORWF _ir_data, W    ;And implement the XOR between 1st and 2nd bytes
00DB   0743           00450     BTFSS STATUS, Z      ;If the result is not 0 (bytes are not equal)
00DC   0A94           00451     GOTO _LOOP           ;Then return to the 'LOOP' label
00DD   0257           00452     COMF _ir_data+3, W   ;Negate the fourth received byte
00DE   0196           00453     XORWF _ir_data+2, W  ;And implement the XOR between 3rd and 4th bytes
00DF   0743           00454     BTFSS STATUS, Z      ;If the result is not 0 (bytes are not equal)
00E0   0A94           00455     GOTO _LOOP           ;Then return to the 'LOOP' label
                      00456 
00E1   0C05           00457     MOVLW 0x05           ;Check the VOL- button (code 0x05)
00E2   0196           00458     XORWF _ir_data+2, W  ;If command is not 0x05
00E3   0743           00459     BTFSS STATUS, Z
00E4   0AE6           00460     GOTO $+2             ;then skip the next line
00E5   0A2D           00461         goto DECREASE_VOLUME
                      00462 
00E6   0C06           00463     MOVLW 0x06           ;Check the VOL+ button (code 0x06)
00E7   0196           00464     XORWF _ir_data+2, W  ;If command is not 0x06
00E8   0743           00465     BTFSS STATUS, Z
00E9   0AEB           00466     GOTO $+2             ;then skip the next line
00EA   0A29           00467         goto INCREASE_VOLUME
MPASM  5.51              PIC20X_PIC12F50X.ASM   8-28-2025  20:24:23         PAGE 10
PIC20X+PIC12F50X+RDA5807M+IR.asm
PIC10F200, PIC10F202, PIC12F508 & PIC12F509                                            *
LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00468 
00EB   0C02           00469     MOVLW 0x02           ;Check the << CH- button (code 0x02)
00EC   0196           00470     XORWF _ir_data+2, W  ;If command is not 0x02
00ED   0743           00471     BTFSS STATUS, Z
00EE   0AF0           00472     GOTO $+2             ;then skip the next line
00EF   0A44           00473         goto SEEK_DOWN 
                      00474 
00F0   0C03           00475     MOVLW 0x03           ;Check the W button (code 0x03)
00F1   0196           00476     XORWF _ir_data+2, W  ;If command is not 0x03
00F2   0743           00477     BTFSS STATUS, Z
00F3   0AF5           00478     GOTO $+2    ;$+2   ;then skip the next three lines
00F4   0A3B           00479         goto CH_UP ;////////////////////////
                      00480 
                      00481 ;   CLRF GPIO           ;Clear the GPIO register
                      00482 
00F5   0A94           00483     GOTO _LOOP           ;and go to the 'SET_OUTPUT' label
                      00484 
                      00485 ; COMF OSCCAL
                      00486 ; SWAPF OSCCAL
                      00487 ; CLRWDT
                      00488 ; nop
                      00489 ; SLEEP
                      00490 
                      00491     END                   ;/* END of the Program */
MPASM  5.51              PIC20X_PIC12F50X.ASM   8-28-2025  20:24:23         PAGE 11
PIC20X+PIC12F50X+RDA5807M+IR.asm
PIC10F200, PIC10F202, PIC12F508 & PIC12F509                                            *
SYMBOL TABLE
  LABEL                             VALUE 

C                                 00000000
CAL0                              00000001
CAL1                              00000002
CAL2                              00000003
CAL3                              00000004
CAL4                              00000005
CAL5                              00000006
CAL6                              00000007
CH_UP                             0000003B
DC                                00000001
DECREASE_VOLUME                   0000002D
DELAY                             0000008D
DELAY_LOOP                        0000008F
F                                 00000001
FOSC4                             00000000
FSR                               00000004
GP0                               00000000
GP1                               00000001
GP2                               00000002
GP3                               00000003
GPIO                              00000006
GPWUF                             00000007
I2C_ACK                           00000084
I2C_CHECK_ACK                     00000071
I2C_NACK                          00000089
I2C_READ_BIT                      0000007B
I2C_READ_BYTE                     00000078
I2C_SHIFT                         0000006D
I2C_START                         0000005D
I2C_STOP                          00000060
I2C_WRITE_0                       0000006C
I2C_WRITE_1                       0000006A
I2C_WRITE_BIT                     00000067
I2C_WRITE_BYTE                    00000064
INCREASE_VOLUME                   00000029
INDF                              00000000
INIT                              00000002
IRx                               00000003
LOOP                              00000029
MAXRAM                            0000001F
NOT_GPPU                          00000006
NOT_GPWU                          00000007
NOT_PD                            00000003
NOT_TO                            00000004
OSCCAL                            00000005
PCL                               00000002
PS0                               00000000
PS1                               00000001
PS2                               00000002
PSA                               00000003
RAM                               00000008
RAM_                              00000018
SCL                               00000001
MPASM  5.51              PIC20X_PIC12F50X.ASM   8-28-2025  20:24:23         PAGE 12
PIC20X+PIC12F50X+RDA5807M+IR.asm
PIC10F200, PIC10F202, PIC12F508 & PIC12F509                                            *
SYMBOL TABLE
  LABEL                             VALUE 

SCL_HIGH                          00000055
SCL_LOW                           00000059
SDA                               00000002
SDA_HIGH                          0000004D
SDA_LOW                           00000051
SEEK_DOWN                         00000044
SET_VOLUME                        00000030
STATUS                            00000003
T0CS                              00000005
T0SE                              00000004
TMR0                              00000001
TRISIO0                           00000000
TRISIO1                           00000001
TRISIO2                           00000002
TRISIO3                           00000003
W                                 00000000
Z                                 00000002
_CHECK_DATA                       000000D9
_CONFIG                           00000FFF
_CP_OFF                           00000FFF
_CP_ON                            00000FF7
_IDLOC0                           00000200
_IDLOC1                           00000201
_IDLOC2                           00000202
_IDLOC3                           00000203
_IntRC_OSC                        00000FFF
_LOOP                             00000094
_MCLRE_OFF                        00000FEF
_MCLRE_ON                         00000FFF
_NEXT_BIT                         000000D1
_OSC_IntRC                        00000FFF
_RECEIVE_BIT                      000000B5
_RECEIVE_BYTE                     000000B3
_WDTE_OFF                         00000FFB
_WDTE_ON                          00000FFF
_WDT_OFF                          00000FFB
_WDT_ON                           00000FFF
__10F202                          00000001
_bit_count                        00000013
_byte_count                       00000012
_count                            00000011
_ir_data                          00000014
ack                               0000000D
bit_count                         0000000A
freq                              00000397
freqB                             00000229
freqH                             0000008A
freqL                             00000040
frequency_h                       00000010
frequency_l                       0000000F
i                                 00000008
i2c_data                          0000000B
j                                 00000009
MPASM  5.51              PIC20X_PIC12F50X.ASM   8-28-2025  20:24:23         PAGE 13
PIC20X+PIC12F50X+RDA5807M+IR.asm
PIC10F200, PIC10F202, PIC12F508 & PIC12F509                                            *
SYMBOL TABLE
  LABEL                             VALUE 

port                              0000000C
volume                            0000000E
volume_init                       00000083


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)

0000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
00C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXX----------
0200 : XXXX------------ ---------------- ---------------- ----------------
0FC0 : ---------------- ---------------- ---------------- ---------------X

All other memory blocks unused.

Program Memory Words Used:   246
Program Memory Words Free:   266


Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :     0 reported,     0 suppressed

